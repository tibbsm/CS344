#!/bin/bash

###############################################################################
# Program Functions
###############################################################################

###############################################################################
# check_arguments()
#
# Usage:
# 	check_arguments [ARGUMENTS]
# 
# Description:
# Checks the number of arguments passed in with corresponding function calls.
# If there is a wrong number of arguments, it prints an error message to
# stderr. Otherwise, it returns 0.
#
###############################################################################
function check_arguments() {

	# Error message variables
	err_message="ERROR: You entered the wrong number of arguments."
	err_info="You entered $(( ${#} - 1)) for the ${1} operation."
	fix_info="The ${1} operation takes no more than 1 argument."
	fix_info_2="The ${1} operation takes exactly 2 arguments."

	# Checks the first argument for the operation
	case "${1}" in
                "dims" | "transpose" | "mean")
			# If there are more than 2 arguments, print error 
			# message and return 1.
 			if [[ "${#}" -gt 2 ]]
			then 
				>&2 echo ${err_message} ${err_info}
				>&2 echo ${fix_info}
				exit 1
			fi	
                        ;;
		"add" | "multiply")	
			# If argument not equal to 3, print error message
			# and return 1.
			if [[ "${#}" -ne 3 ]]
			then 	
				>&2 echo ${err_message} ${err_info}
				>&2 echo ${fix_info_2}
				exit 1
			fi
			;;
	esac
}

###############################################################################
# check_files()
#
# Usage:
# 	check_files [ARGUMENTS]
#
# Description:
# This function checks whether passed in files are readable or not. If the
# files cannot be read it prints an error message and returns. Otherwise,
# it returns 0. 
###############################################################################
function check_files() {

	# For each argument passed in..
	for arg in "${@}"
	do
		# If the file is not readable print error message and return 1.
		if [[ ! -r "${arg}" ]]
		then 
			>&2 echo "ERROR: '"${arg}"' file cannot be read."
			exit 1
		fi
	done
}

###############################################################################
# check_matrix_dimensions()
#
# Usage:
# 	check_matrix_dimensions OPERATION MATRIX_LEFT MATRIX_RIGHT
#
# Descriptions:
# This function checks to see if the matrices are capable of being summed or
# multiplied. Prints an error message and returns 1 if the matrices are not
# compatible. Otherwise, it returns 0. 
###############################################################################
function check_matrix_dimensions() {
	# Matrix dimension variables
        numOfRows1="$(wc -l < $2)"
        numOfItems1="$(wc -w < $2)"
        numOfCols1="$(( numOfItems1 / numOfRows1 ))"

        numOfRows2="$(wc -l < $3)"
        numOfItems2="$(wc -w < $3)"
        numOfCols2="$(( numOfItems2 / numOfRows2 ))"

	# If add operation, but matrices are the same dimensions, print error
	# message and return 1,	
	if [[ "${1}" == "add" ]] && [[ "${numOfRows1}" -ne "${numOfRows2}" ]]  ||
           [[ "${1}" == "add" ]] && [[ "${numOfCols1}" -ne "${numOfCols2}" ]] 
	then 
		>&2 echo "Error: You cannot add matrices of different sizes."
		exit 1
	# If multiply operation, but matrix 1's number of colums does not 
	# equal matrix 2's number of rows, print error and return 1.
	elif [[ "${1}" == "multiply" && "${numOfCols1}" -ne "${numOfRows2}" ]]
	then
		>&2 echo "Error: You cannot multiply these matrices."
		exit 1
	fi	
}


###############################################################################
# get_dimensions()
#
# Usage:
# 	get_dimensions [MATRIX]
#
# Descriptions:
# This functions takes a matrix file and returns the number of rows, followed
# by a space, then the number of columns.
###############################################################################

function get_dimensions() {
	
	# Initialize the temp file to hold the matrix
	matrixFile="tempMatrixFile$$"

	# If there is a matrix file copy it into matrixFile
	if [[ "${#}" -gt 1 ]]
	then 
		cat "${2}" > "${matrixFile}"
	# Otherwise, get data from stdin
	else 
		cat > "${matrixFile}"
	fi
		
	# Initialize the row count
	row=0

	# Count each line in the file (rows)
	while read myLine
	do
        	((row++))
	done < "${matrixFile}"

	# Initialize columns variable to the total # of items in the matrix 
	col=$(wc -w < "${matrixFile}")

	# Divide the total items by the # of rows to get the # of columns
	col=$((col / row))

	# Print out the dimensions of the matrix [row] [col]
	echo "${row}" "${col}"

	# Remove the temp file
	rm "${matrixFile}"
}

###############################################################################
# transpose_matrix()
#
# Usage: 
# 	transpose_matrix [MATRIX] 
#
# Description:
# This function reflects the elements of a matrix along the main diagonal.
# A MxN matrix will become an NxM matrix and the values along the main
# diagonal will remain unchanged.
###############################################################################
function transpose_matrix() {

	# Initialize temporary file to hold the matrix
	matrixFile="tempMatrixFile$$"

	# If a matrix file is passed in copy it to the temp file
        if [[ ${#} -gt 1 ]]
        then
                cat ${2} > "${matrixFile}"
	# Otherwise, get the matrix information from stdin
        else
                cat > "${matrixFile}"
        fi

	# Temporary file to build and store transposed matrix. 
	transposeTempFile="transpose_matrixTempFile$$"

	# Matrix dimension variables
	numOfRows="$(wc -l < $matrixFile)"
	numOfItems="$(wc -w < $matrixFile)"
	numOfCols="$(( numOfItems / numOfRows ))"

	# This variable tracks which column the function is transposing
	colIndex=1

	# For each column in the original matrix
	while [[ "${colIndex}" -le "${numOfCols}" ]]
	do
		# This variable tracks the row the function is working on
		rowIndex=1

		# For each row in the original matrix
		while read myLine
		do
			# If not the last row, append number at colIndex
			# followed by a tab
			if [[ "${rowIndex}" -lt "${numOfRows}" ]]
			then
				echo ${myLine} | cut -d " " -f "${colIndex}" | tr '\n' '\t' >> "${transposeTempFile}"
				(( rowIndex++ ))
			# If last row, append number followed by a new line
			else
				echo ${myLine} | cut -d " " -f "${colIndex}" >> "${transposeTempFile}"
			fi
		done < "${matrixFile}"
	
		# Increment index to transpose the next column	
		(( colIndex++ ))
	done

	# Display the transposed matrix & delete the temp file
	cat "${transposeTempFile}"
	rm "${transposeTempFile}" "${matrixFile}"
}


###############################################################################
# Program Functions
###############################################################################
# matrix mean [MATRIX]
# mean should take an MxN matrix and return an 1xN row vector, where the first element is the mean of column one, the second element is the mean of column two, and so on.
function getMean() {

	matrixFile="tempMatrixFile$$"

        if [[ $# > 1 ]]
        then
                cat $2 > "$matrixFile"
        else
                cat > "$matrixFile"
        fi

	# Temporary file to hold column means
	tempMeanFile="meanTempFile$$"	

	# Matrix dimension variables
	numOfRows=$(wc -l < $matrixFile)
	numOfItems=$(wc -w < $matrixFile)
	numOfCols=$(( numOfItems / numOfRows ))

	# Column index to track which column's mean the function is calculating
	colIndex=1

	# For each column...
	while [[ $colIndex -le $numOfCols ]]
	do
		# Initialize column's sum variable	
		sum=0

		# For every row/number in a column...
		while read myLine
		do
			# Get the number from the column & add it to the sum			
			num=$(echo $myLine | cut -d " " -f $colIndex)
			sum=$(( sum + num ))
		done < $matrixFile

		# Calculate the mean and round to the nearest integer
		(( mean= ($sum + ($numOfRows /2) * (($sum > 0) * 2 - 1)) / $numOfRows ))
		
		# Copy columns mean to the temp file
		echo -n $mean >> $tempMeanFile

		# If row isn't last row, append a tab to the file
		if [[ $colIndex -lt $numOfCols ]]
		then
			echo -n -e '\t' >> $tempMeanFile
		# If last row, append new line to the file
		else
			echo >> $tempMeanFile
		fi

		# Increment column index to work on the next column
		(( colIndex++ ))
	done

	# Display the means and delete the tempMeanFile
	cat $tempMeanFile
	rm $tempMeanFile $matrixFile 
}

###############################################################################
# Program Functions
###############################################################################
# matrix add MATRIX_LEFT MATRIX_RIGHT
# add should take two MxN matrices and add them together element-wise to produce an MxN matrix. add should return an error if the matrices do not have the same dimensions.
function addMatrices() {

	# Temporary file to hold the sums from adding the matrices
	tempAddFile="addMatricesTempFile$$"

	# Matrix dimension variables
        numOfRows=$(wc -l < $1)
        numOfItems=$(wc -w < $1)
        numOfCols=$(( numOfItems / numOfRows ))

	# Read each line of data from both matrices
	while read myLine1 && read myLine2 <&3
	do
		# Initialize variables hold sums and track column indices
		sum=0
		colIndex=1
		
		# For each column in a row
		while [[ $colIndex -le $numOfCols ]]
		do
			# Get the numbers to add from each matrix
			num1=$(echo $myLine1 | cut -d " " -f $colIndex)
			num2=$(echo $myLine2 | cut -d " " -f $colIndex)

			# Calculate the sum
			sum=$(( num1 + num2 ))

			# If not the last column, append tab after number
			if [[ $colIndex -lt $numOfCols ]]
			then 
				echo -e -n "$sum\t" >> $tempAddFile
			# If last column, append new line after number
			else
				echo $sum >> $tempAddFile
			fi
			
			# Increment column index
			(( colIndex++ ))
		done

	done<$1 3<$2
		
	cat $tempAddFile
	rm $tempAddFile	
}

###############################################################################
# Program Functions
###############################################################################
# matrix multiply MATRIX_LEFT MATRIX_RIGHT   
# multiply should take an MxN and NxP matrix and produce an MxP matrix. Note that, unlike addition, matrix multiplication is not commutative. That is A*B != B*A.
function multiplyMatrices() {

	# Temporary file to hold the products of multiplying matrices
	tempMultiplyFile="multiplyMatricesTempFile$$"

	# Temporary file to hold transposed matrix 2
	tempMatrix="tempMultMatrixFile$$"

	# Transpose matrix 2 into the tempMatrix
	transpose_matrix $@ > ${tempMatrix}

	# Initialize variable to hold number of rows
	numOfRows1=$(wc -l < $1)
	numOfItems1=$(wc -w < $1)
        numOfCols1=$(( numOfItems1 / numOfRows1 ))

	numOfRows2=$(wc -l < $2)
	numOfItems2=$(wc -w < $2)
        numOfCols2=$(( numOfItems2 / numOfRows2 ))

#	echo $numOfRows1 $numOfCols1
#	echo $numOfRows2 $numOfCols2

	while read myLine1
	do
		index1=0
		while read myLine2
		do
			sum=0
			for ((index2=1; index2 <= $numOfCols2; index2++))
			do
				num1=$(echo $myLine1 | cut -d " " -f $index2)
				num2=$(echo $myLine2 | cut -d " " -f $index2)
				sum=$(( sum + (num1 * num2) ))
			done

			(( index1++ ))

			if [[ $index1 -lt $numOfCols2 ]]
			then
				echo -e -n "$sum\t" >> $tempMultiplyFile
			else
				echo $sum >> $tempMultiplyFile
			fi
		done < $tempMatrix
	done < $1

	if [[ -r $tempMultiplyFile ]]
	then
		cat $tempMultiplyFile
		rm $tempMultiplyFile
	fi
	if [[ -r $tempMatrix ]]
	then
	#	cat $tempMatrix
		rm $tempMatrix
	fi
}

###############################################################################
# Main
###############################################################################
# main()
#
# Usage:
# 	main [<options>] [<arguments>]
#
# Description:
#   	Entry point for the program. Handles basic option parsing and dispatching
function main() {
	case "$1" in 
		"dims")
			check_arguments $@
			check_files "${@:2}"
			get_dimensions $@
			;;
		"transpose")
			check_arguments $@
			check_files "${@:2}"
			transpose_matrix $@
			;;
		"mean")
			check_arguments $@
			check_files "${@:2}"
			getMean $@
			;;
		"add")
			check_arguments $@
			check_files "${@:2}"
			check_matrix_dimensions $@
			addMatrices $2 $3
			;;
		"multiply")
			check_arguments $@
			check_files "${@:2}"
			check_matrix_dimensions $@
			multiplyMatrices $2 $3
			;;
		*)
			>&2 echo "ERROR: Operation '$1' unknown."
                        exit 1	
			;;
	esac
}

# Call main() after everything has been defined.
main "$@"

