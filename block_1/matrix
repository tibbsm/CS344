#!/bin/bash

function checkArguments() {
	
	case "$1" in
                "dims" | "transpose" | "mean")
 			if [[ $# > 2 ]]
			then 
				>&2 echo "ERROR: You entered too many arguments ($(($#-1))) for the $1 operation."
				exit 1
			fi	
                        ;;
		"add" | "multiply")	
			if [[ $# != 3 ]]
			then 	
				>&2 echo "ERROR: You entered $(($#-1)) arguments instead of 2 for the $1 operation."
				exit 1
			fi
			;;
	esac
}

function checkFiles() {

	case "$1" in 
		"dims" | "transpose" | "mean")
			if [[ $# > 1 && ! -r $2  ]] 
       			then
				>&2 echo "ERROR: $2 file is not readable."
				exit 1
       			fi
			;;
		"add" | "multiply")
			if [[ ! -r $2  ]]  
       			then
				>&2 echo "ERROR: $2 file is not readable."
				exit 1
			elif [[ ! -r $3 ]]
			then
				>&2 echo "ERROR: $3 file is not readable."
				exit 1
       			fi
			;;
	esac
}

function checkMatrixDimensions() {
	# Matrix dimension variables
        numOfRows1=$(wc -l < $2)
        numOfItems1=$(wc -w < $2)
        numOfCols1=$(( numOfItems1 / numOfRows1 ))

        numOfRows2=$(wc -l < $3)
        numOfItems2=$(wc -w < $3)
        numOfCols2=$(( numOfItems2 / numOfRows2 ))


	if [[ $1 == "add" ]] 
	then 
		if [[ $numOfRows1 -ne $numOfRows2 ]] || [[ $numOfCols1 -ne $numOfCols2 ]]
		then			
			>&2 echo "Error: You cannot use the add function on matrices of different sizes."
			exit 1
		fi	
	elif [[ $1 == "multiply" ]]
	then
# In order for matrix multiplication to be defined, the number of columns in the first matrix must be equal to the number of rows in the second matrix.
		if [[ $numOfCols1 -ne $numOfRows2 ]]
		then 
			echo $numOfCols1 $numOfRows2
			>&2 echo "Error: You cannot multiply these matrices."
			exit 1
		fi
	fi	
}


# matrix dims [MATRIX]
# dims should print the dimensions of the matrix as the number of rows, followed by a space, then the number of columns.

function getDimensions() {

	matrixFile="tempMatrixFile$$"

	if [[ $# > 1 ]]
	then 
		cat $2 > "$matrixFile"
	else 
		cat > "$matrixFile"
	fi
		

	# Initialize the row count
	row=0

	# Count each line in the file (rows)
	while read myLine
	do
        	((row++))
	done < $matrixFile

	# Initialize columns variable to the total number of items in the matrix 
	col=$(wc -w < $matrixFile)

	# Divide the total items by the number of rows to get the number of columns
	col=$((col / row))

	# Print out the dimensions of the matrix [row] [col]
	echo $row $col

	rm $matrixFile
}

# matrix transpose [MATRIX]
# transpose should reflect the elements of the matrix along the main diagonal.
# Thus, an MxN matrix will become an NxM matrix and the values along the main diagonal will remain unchanged.
function transposeMatrix() {

	matrixFile="tempMatrixFile$$"

        if [[ $# > 1 ]]
        then
                cat $2 > "$matrixFile"
        else
                cat > "$matrixFile"
        fi

	# Temporary file to build and store transposed matrix. Will not be saved.
	transposeTempFile="transposeMatrixTempFile$$"

	# Matrix dimension variables
	numOfRows=$(wc -l < $matrixFile)
	numOfItems=$(wc -w < $matrixFile)
	numOfCols=$(( numOfItems / numOfRows ))

	# This variable keeps track of which column the function is currently transposing
	colIndex=1

	# For each column in the original matrix
	while [[ $colIndex -le $numOfCols ]]
	do
		# This variable keeps track of which row the function is working on
		rowIndex=1

		# For each row in the original matrix
		while read myLine
		do
			# If not the last row, append number at colIndex followed by a tab
			if [[ $rowIndex -lt $numOfRows ]]
			then
				echo $myLine | cut -d " " -f $colIndex | tr '\n' '\t' >> $transposeTempFile
				(( rowIndex++ ))
			# If last row, append number followed by a new line
			else
				echo $myLine | cut -d " " -f $colIndex >> $transposeTempFile
			fi
		done < $matrixFile
	
		# Increment index to transpose the next column	
		(( colIndex++ ))
	done

	# Display the transposed matrix & delete the temp file
	cat $transposeTempFile
	rm $transposeTempFile $matrixFile
}


# matrix mean [MATRIX]
# mean should take an MxN matrix and return an 1xN row vector, where the first element is the mean of column one, the second element is the mean of column two, and so on.
function getMean() {

	matrixFile="tempMatrixFile$$"

        if [[ $# > 1 ]]
        then
                cat $2 > "$matrixFile"
        else
                cat > "$matrixFile"
        fi

	# Temporary file to hold column means
	tempMeanFile="meanTempFile$$"	

	# Matrix dimension variables
	numOfRows=$(wc -l < $matrixFile)
	numOfItems=$(wc -w < $matrixFile)
	numOfCols=$(( numOfItems / numOfRows ))

	# Column index to track which column's mean the function is calculating
	colIndex=1

	# For each column...
	while [[ $colIndex -le $numOfCols ]]
	do
		# Initialize column's sum variable	
		sum=0

		# For every row/number in a column...
		while read myLine
		do
			# Get the number from the column & add it to the sum			
			num=$(echo $myLine | cut -d " " -f $colIndex)
			sum=$(( sum + num ))
		done < $matrixFile

		# Calculate the mean and round to the nearest integer
		(( mean= ($sum + ($numOfRows /2) * (($sum > 0) * 2 - 1)) / $numOfRows ))
		
		# Copy columns mean to the temp file
		echo -n $mean >> $tempMeanFile

		# If row isn't last row, append a tab to the file
		if [[ $colIndex -lt $numOfCols ]]
		then
			echo -n -e '\t' >> $tempMeanFile
		# If last row, append new line to the file
		else
			echo >> $tempMeanFile
		fi

		# Increment column index to work on the next column
		(( colIndex++ ))
	done

	# Display the means and delete the tempMeanFile
	cat $tempMeanFile
	rm $tempMeanFile $matrixFile 
}

# matrix add MATRIX_LEFT MATRIX_RIGHT
# add should take two MxN matrices and add them together element-wise to produce an MxN matrix. add should return an error if the matrices do not have the same dimensions.
function addMatrices() {

	# Temporary file to hold the sums from adding the matrices
	tempAddFile="addMatricesTempFile$$"

	# Matrix dimension variables
        numOfRows=$(wc -l < $1)
        numOfItems=$(wc -w < $1)
        numOfCols=$(( numOfItems / numOfRows ))

	# Read each line of data from both matrices
	while read myLine1 && read myLine2 <&3
	do
		# Initialize variables hold sums and track column indices
		sum=0
		colIndex=1
		
		# For each column in a row
		while [[ $colIndex -le $numOfCols ]]
		do
			# Get the numbers to add from each matrix
			num1=$(echo $myLine1 | cut -d " " -f $colIndex)
			num2=$(echo $myLine2 | cut -d " " -f $colIndex)

			# Calculate the sum
			sum=$(( num1 + num2 ))

			# If not the last column, append tab after number
			if [[ $colIndex -lt $numOfCols ]]
			then 
				echo -e -n "$sum\t" >> $tempAddFile
			# If last column, append new line after number
			else
				echo $sum >> $tempAddFile
			fi
			
			# Increment column index
			(( colIndex++ ))
		done

	done<$1 3<$2
		
	cat $tempAddFile
	rm $tempAddFile	
}

# matrix multiply MATRIX_LEFT MATRIX_RIGHT   
# multiply should take an MxN and NxP matrix and produce an MxP matrix. Note that, unlike addition, matrix multiplication is not commutative. That is A*B != B*A.
function multiplyMatrices() {

	# Temporary file to hold the products of multiplying matrices
	tempMultiplyFile="multiplyMatricesTempFile$$"

	# Temporary file to hold transposed matrix 2 
	tempMatrixFile="tempMatrixFile$$"
	
	# Transpose matrix 2 into the tempMatrixFile
	transposeMatrix $@ > "$tempMatrixFile"

	# Initialize variable to hold number of rows
	numOfRows1=$(wc -l < $1)
	numOfRows2=$(wc -l < $2)

	while read myLine1
	do
		index1=0
		while read myLine2
		do
			sum=0
			for ((index2=1; index2 <= $numOfRows2; index2++))
			do
				num1=$(echo $myLine1 | cut -d " " -f $index2)
				num2=$(echo $myLine2 | cut -d " " -f $index2)
				sum=$(( sum + (num1 * num2) ))
			done

			(( index1++ ))

			if [[ $index1 -lt $numOfRows1 ]]
			then
				echo -e -n "$sum\t" >> $tempMatrixFile
			else
				echo $sum >> $tempMultiplyFile
			fi
		done < $tempMatrixFile
	done < $1

	if [[ -r $tempMultiplyFile ]]
	then
		cat $tempMultiplyFile
		rm $tempMultiplyFile
	elif [[ -r $tempMatrix ]]
	then
		cat $tempMatrixFile
		rm $tempMatrixFile
	fi
}

####################
# Main
####################
# main()
#
# Usage:
# 	main [<options>] [<arguments>]
#
# Description:
#   	Entry point for the program. Handles basic option parsing and dispatching
function main() {
	case "$1" in 
		"dims")
			checkArguments $@
			checkFiles $@
			getDimensions $@
			;;
		"transpose")
			checkArguments $@
			checkFiles $@
			transposeMatrix $@
			;;
		"mean")
			checkArguments $@
			checkFiles $@
			getMean $@
			;;
		"add")
			checkArguments $@
			checkFiles $@
			checkMatrixDimensions $@
			addMatrices $2 $3
			;;
		"multiply")
			checkArguments $@
			checkFiles $@
			checkMatrixDimensions $@
			multiplyMatrices $2 $3
			;;
		*)
			echo "OPERATION UNKNOWN!!!"
			;;
	esac
}

# Call main() after everything has been defined.
main "$@"

