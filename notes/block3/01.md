# Lecture 3.1 - Processes

[**Youtube**](https://www.youtube.com/watch?v=1R9h-H2UnLs)

## The Process 
* Process Management is a necessary component of a multiprogrammable operating system
* Process:
  * An instance of an executing program, with a collection of execution resources associated with it

## UNIX Process Components
* A unique identity (process id aka pid) :: `pid_t pid = getpid();`
* A virtual address space (from 0 to memory limit)
* Program code and data (variables) in memory
* User/group identity (controls what you can access), unmask value
* An execution environment all to itself 
  * Environment variables 
  * Current workig directory
  * List of open files
  * A description of actions to take on receiving signals
* Resource limits, scheduling priority
* and more... see the exec() man page

## Programs vs Processes
* A **program** is the executable code
* A **process** is a running instance of a program
* More than one process can be concurrently executing the same program code, with separate process resources

## Important Process States in UNIX
![1](./images/1_1.png)

## How Do You Create a Process?
* Let the shell do it for you!
  * When you execute a program, the shell creates the process for you
* In some cases, you'll want to do it yourself
  * Our shell-writing assignment
* Unix provides a C API for creating and managing processes explicitly, as the following material shows


## Managing Processes
* Functions we'll be covering:
    * fork()
    * The exec() family
        * execl(), execlp(), execv(), execvp()
    * exit()
    * wait(), waitpid()
    * getpid()
    * getenv(), putenv()

## How to Start a New Process
![2](./images/1_2.png)
* Process A and B are nearly identical copies, both running the same code, and continuing on from where the fork() call occured.

## Process A == Process B??
* The two processes have different pids
* Each process return a different value from fork()
* Process B gets copies of all the open file descriptors of Process A
* Process B has all the same variables set to the same value as Process A, but they are now separately managed!

## fork()
* A sample program using fork()
``` C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnpid = -5;
	int ten = 10;

	spawnpid = fork();
	switch (spawnpid)
	{
		// If something went wrong, fork() returns -1 to the
		// parent process and sets the global variable errno;
		// no child process was created
		case -1:
			perror("Hull Breach!");
			exit(1);
			break;
		// In the child process, fork() returns 0	
		case 0:
			ten = ten + 1;
			printf("I am the child! ten = %d\n", ten);
			break;
		// In the parent process, fork() returns the process
		// id of the child process that was just created
		default:
			ten = ten - 1;
			printf("I am the parent! ten = %d\n", ten);
			break;
	}
	printf("This will be executed by both of us!\n")
}
```