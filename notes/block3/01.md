# Lecture 3.1 - Processes

[**Youtube**](https://www.youtube.com/watch?v=1R9h-H2UnLs)

## The Process 
* Process Management is a necessary component of a multiprogrammable operating system
* Process:
  * An instance of an executing program, with a collection of execution resources associated with it

## UNIX Process Components
* A unique identity (process id aka pid) :: `pid_t pid = getpid();`
* A virtual address space (from 0 to memory limit)
* Program code and data (variables) in memory
* User/group identity (controls what you can access), unmask value
* An execution environment all to itself 
  * Environment variables 
  * Current workig directory
  * List of open files
  * A description of actions to take on receiving signals
* Resource limits, scheduling priority
* and more... see the exec() man page

## Programs vs Processes
* A **program** is the executable code
* A **process** is a running instance of a program
* More than one process can be concurrently executing the same program code, with separate process resources

## Important Process States in UNIX
![1](./images/1_1.png)

## How Do You Create a Process?
* Let the shell do it for you!
  * When you execute a program, the shell creates the process for you
* In some cases, you'll want to do it yourself
  * Our shell-writing assignment
* Unix provides a C API for creating and managing processes explicitly, as the following material shows


## Managing Processes
* Functions we'll be covering:
    * fork()
    * The exec() family
        * execl(), execlp(), execv(), execvp()
    * exit()
    * wait(), waitpid()
    * getpid()
    * getenv(), putenv()

## How to Start a New Process
![2](./images/1_2.png)
* Process A and B are nearly identical copies, both running the same code, and continuing on from where the fork() call occured.

## Process A == Process B??
* The two processes have different pids
* Each process return a different value from fork()
* Process B gets copies of all the open file descriptors of Process A
* Process B has all the same variables set to the same value as Process A, but they are now separately managed!

## fork()
* A sample program using fork()
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnpid = -5;
	int ten = 10;

	spawnpid = fork();
	switch (spawnpid)
	{
		// If something went wrong, fork() returns -1 to the
		// parent process and sets the global variable errno;
		// no child process was created
		case -1:
			perror("Hull Breach!");
			exit(1);
			break;
		// In the child process, fork() returns 0	
		case 0:
			ten = ten + 1;
			printf("I am the child! ten = %d\n", ten);
			break;
		// In the parent process, fork() returns the process
		// id of the child process that was just created
		default:
			ten = ten - 1;
			printf("I am the parent! ten = %d\n", ten);
			break;
	}
	printf("This will be executed by both of us!\n");
}
```

## Results
```
➜ ./forktest
I am the parent! ten = 9
This will be executed by both of us!
I am the child! ten = 11
This will be executed by both of us!
```

## Key Items Inherited
* Inherited by the child form the parent:
  * Program code
  * Process credentials (real/effective/saved UIDs and GIDs)
  * Virtual memory contents, including stack and heap
  * Open file descriptors
  * Close-on-exec flags
  * Signal handling settings
  * process group ID
  * current working directory (CWD)
  * controlling terminal
  * ...

## Key Items Unique to the Child Process
* Unique to the child:
  * Process ID
  * Parent process ID is different (it's the parent that just spawned it)
  * Own copy of file descriptors
  * Process, text, data, and other memory locks are NOT inherited
  * Pending signals initialized to the empty set
  * ...

## fork() Forms a Family Tree
![3](./images/1_3.png)

## Child Process Termination
* Child process can exit for two reasons
    * It completes the execution and exits normally
        * Case 1: The child process completed what it was supposed to do and exited with a successful exit status (ie 0)
        * Case 2: The child process encountered an error condition, recognized it, and exited with a non-successful exit status (ie non-zero)
    * It was killed by a signal 
        * The child process was sent a signal that by default terminates a process, and the child process *did not catch it*
* How do parents check to see if child processes have terminated?

## Checking the Exti Status
* Both of these commands check for child process termination:
  * wait()
  * waitpid()
* For both functions, you pass in a pointer to which the OS writes an int, which identifies how the child exited
  * We examine this int with various macros to learn what happened

## wait vs waitpid
* wait() will **block** - until *any* one child process terminates; returns the process id of the terminated child
* waitpid() will **block** - until process with the *specified* process ID terminates (or has already terminated); returns the process id of the terminated child
    * If you pass it a special flag, it will check if the specified child process has terminated, then immediately return even if the specified child process hasn't terminated yet

## wait() and waitpid() Syntax

* `pid_t wait(int *childExitMethod);`
* `pid_t waitpid(pid_t pid, int *childExitMethod, int options);`
* Block this parent until any child process terminates:
    * `childPID = wait(&childExitMethod);`
* Block this parent until the specified child process terminates:
    * `childPID_actual = waitpid(childPID_intent, &childExitMethod, 0);`
* Check if any process has completed, return immediately with 0 if none have:
    * `childPID = waitpid(-1, &childExitMethod, WNOHANG);`
* Check if the process specified has completed, return immediately with 0 if it hasn't:
    * `childPID_actual = waitpid(childPID_intent, &childExitMethod, WNOHANG);`


## Proper waitpid() Placement
* **forwaittest.c**
```C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    pid_t spawnPid = -5;
    int childExitMethod = -5;

    spawnPid = fork();
    if (spawnPid == -1) 
    {
        perror("Hull Breach!\n");
        exit(1);
    }
    else if (spawnPid == 0)
    {
        printf("CHILD: PID: %d, exiting!\n", spawnPid);
        exit(0);
    }

    printf("PARENT: PID: %d, waiting...\n", spawnPid);
    waitpid(spawnPid, &childExitMethod, 0);
    printf("PARENT: Child process terminated, exiting!\n");
    exit(0);
}
```
* **Results**
```
➜  block3 git:(master) ✗ ./forkwaittest
PARENT: PID: 12826, waiting...
CHILD: PID: 0, exiting!
PARENT: Child process terminated, exiting!
```