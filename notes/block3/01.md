# Lecture 3.1 - Processes

[**Youtube**](https://www.youtube.com/watch?v=1R9h-H2UnLs)

## The Process 
* Process Management is a necessary component of a multiprogrammable operating system
* Process:
  * An instance of an executing program, with a collection of execution resources associated with it

## UNIX Process Components
* A unique identity (process id aka pid) :: `pid_t pid = getpid();`
* A virtual address space (from 0 to memory limit)
* Program code and data (variables) in memory
* User/group identity (controls what you can access), unmask value
* An execution environment all to itself 
  * Environment variables 
  * Current workig directory
  * List of open files
  * A description of actions to take on receiving signals
* Resource limits, scheduling priority
* and more... see the exec() man page

## Programs vs Processes
* A **program** is the executable code
* A **process** is a running instance of a program
* More than one process can be concurrently executing the same program code, with separate process resources

## Important Process States in UNIX
![1](./images/1_1.png)

## How Do You Create a Process?
* Let the shell do it for you!
  * When you execute a program, the shell creates the process for you
* In some cases, you'll want to do it yourself
  * Our shell-writing assignment
* Unix provides a C API for creating and managing processes explicitly, as the following material shows


## Managing Processes
* Functions we'll be covering:
    * fork()
    * The exec() family
        * execl(), execlp(), execv(), execvp()
    * exit()
    * wait(), waitpid()
    * getpid()
    * getenv(), putenv()

## How to Start a New Process
![2](./images/1_2.png)
* Process A and B are nearly identical copies, both running the same code, and continuing on from where the fork() call occured.

## Process A == Process B??
* The two processes have different pids
* Each process return a different value from fork()
* Process B gets copies of all the open file descriptors of Process A
* Process B has all the same variables set to the same value as Process A, but they are now separately managed!

## fork()
* A sample program using fork()
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnpid = -5;
	int ten = 10;

	spawnpid = fork();
	switch (spawnpid)
	{
		// If something went wrong, fork() returns -1 to the
		// parent process and sets the global variable errno;
		// no child process was created
		case -1:
			perror("Hull Breach!");
			exit(1);
			break;
		// In the child process, fork() returns 0	
		case 0:
			ten = ten + 1;
			printf("I am the child! ten = %d\n", ten);
			break;
		// In the parent process, fork() returns the process
		// id of the child process that was just created
		default:
			ten = ten - 1;
			printf("I am the parent! ten = %d\n", ten);
			break;
	}
	printf("This will be executed by both of us!\n");
}
```

## Results
```
➜ ./forktest
I am the parent! ten = 9
This will be executed by both of us!
I am the child! ten = 11
This will be executed by both of us!
```

## Key Items Inherited
* Inherited by the child form the parent:
  * Program code
  * Process credentials (real/effective/saved UIDs and GIDs)
  * Virtual memory contents, including stack and heap
  * Open file descriptors
  * Close-on-exec flags
  * Signal handling settings
  * process group ID
  * current working directory (CWD)
  * controlling terminal
  * ...

## Key Items Unique to the Child Process
* Unique to the child:
  * Process ID
  * Parent process ID is different (it's the parent that just spawned it)
  * Own copy of file descriptors
  * Process, text, data, and other memory locks are NOT inherited
  * Pending signals initialized to the empty set
  * ...

## fork() Forms a Family Tree
![3](./images/1_3.png)

## Child Process Termination
* Child process can exit for two reasons
    * It completes the execution and exits normally
        * Case 1: The child process completed what it was supposed to do and exited with a successful exit status (ie 0)
        * Case 2: The child process encountered an error condition, recognized it, and exited with a non-successful exit status (ie non-zero)
    * It was killed by a signal 
        * The child process was sent a signal that by default terminates a process, and the child process *did not catch it*
* How do parents check to see if child processes have terminated?

## Checking the Exti Status
* Both of these commands check for child process termination:
  * wait()
  * waitpid()
* For both functions, you pass in a pointer to which the OS writes an int, which identifies how the child exited
  * We examine this int with various macros to learn what happened

## wait vs waitpid
* wait() will **block** - until *any* one child process terminates; returns the process id of the terminated child
* waitpid() will **block** - until process with the *specified* process ID terminates (or has already terminated); returns the process id of the terminated child
    * If you pass it a special flag, it will check if the specified child process has terminated, then immediately return even if the specified child process hasn't terminated yet

## wait() and waitpid() Syntax

* `pid_t wait(int *childExitMethod);`
* `pid_t waitpid(pid_t pid, int *childExitMethod, int options);`
* Block this parent until any child process terminates:
    * `childPID = wait(&childExitMethod);`
* Block this parent until the specified child process terminates:
    * `childPID_actual = waitpid(childPID_intent, &childExitMethod, 0);`
* Check if any process has completed, return immediately with 0 if none have:
    * `childPID = waitpid(-1, &childExitMethod, WNOHANG);`
* Check if the process specified has completed, return immediately with 0 if it hasn't:
    * `childPID_actual = waitpid(childPID_intent, &childExitMethod, WNOHANG);`


## Proper waitpid() Placement
* **forwaittest.c**
```C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    pid_t spawnPid = -5;
    int childExitMethod = -5;

    spawnPid = fork();
    if (spawnPid == -1) 
    {
        perror("Hull Breach!\n");
        exit(1);
    }
    else if (spawnPid == 0)
    {
        printf("CHILD: PID: %d, exiting!\n", spawnPid);
        exit(0);
    }

    printf("PARENT: PID: %d, waiting...\n", spawnPid);
    waitpid(spawnPid, &childExitMethod, 0);
    printf("PARENT: Child process terminated, exiting!\n");
    exit(0);
}
```
* **Results**
```
➜  block3 git:(master) ✗ ./forkwaittest
PARENT: PID: 12826, waiting...
CHILD: PID: 0, exiting!
PARENT: Child process terminated, exiting!
```

## Checking the Exit Status - Normal Termination
* `wait(&childExitMethod)` and `waitpid(..., &childExitMethod, ...)` can identify two ways a process can terminate
* If the process **terminates normally**, then the WIFEXITED macro returns non-zero:
    * `if(WIFEXITED(childExitMethod) != 0) printf("The process exited normally\n");`
* We can get the actual exit status with the WEXITSTATUS macro:
    * `int exitstatus = WEXITSTATUS(childExitMethod);`

## Checking the Exit Status - Signal Termination
* If the process **terminates by a signal**, then the WIFSIGNALED macro returns non-zero: 
    * `if(WIFSIGNALED(childExitMethod) != 0) printf("The process was terminated by a signal\n");`
* We can get the terminating signal with the WTERMSIG macro:
    * `int termSignal = WTERMSIG(childExitMethod);`

## Checking the Exit Status - Exclusivity
* Barring the use of the non-standard WCONTINUED and WUNTRACED flags in waitpid(), only *one* of the WIFEXITED() and WIFSIGNALED() macros will be non-zero!    
* Thus, if you want to know how a child process died, you need to use both WIFEXITED and WIFSIGNALED!
* If the child process has terminated normally, do not run WTERMSIG() on it, as there is *no signal number* that killed it!
* If the child process was terminated by a signal, do not run WEXITSTATUS() on it, as it has *no exit status*(i.e., no exit() or return() function were executed)!

## Checking the Exit Status
```C
int childExitMethod;
pid_t childPID = wait(&childExitMethod);

if (childPID == -1)
{
    perror("Wait failed");
    exit(1);
}

// Non-zero evaluates to true in C
if (WIFEXITED(childExitMethod))
{
    printf("The process exited normally\n");
    int exitStatus = WEXITSTATUS(childExitMethod);
    printf("exit status was %d\n", exitStatus);
}
else
    // This statement is true, but it never hurts to examine WIFSIGNALED(), also to make sure!
    printf("Child terminated by a signal\n");
```

## How to Run a Completely Different Program
* `fork()` always makes a copy of your *current* program
* What id you want to start a process that is running a completely different program?
* For this we use the `exec...()` family

## exec...() - Execute
* `exec...()` replaces the currently running program with a *new* program that you specify
* The `exec...()` functions do not return - they destroy the currently running program
    * No line after a successful exec...() call will run
* You can specify arguments to exec...(): these become the command line arguments that show up as argc/argv in C, and as the $1, $2, etc positional parameters in a bash shell

## Two Types of Execution
* `int execl(char *path, char *arg1, ..., char *argn);`
* Executes the program specified by *path*, and gives it the command line arguments specified by strings *arg1* through *argn*

* `int execv(char *path, char *argv[]);`
* Executes the program specified by *path*, and gives it the command line arguments indicated by the pointers in *argv*

## Current Working Directory
* execl() and execv() do not examine the PATH variable - they only look in the current working directory (but see the next slide)
* If you don't specify a fully qualified path name, then your programs will not be executed, even if they are in a directory listed PATH, and execl() and execv() will return with an error 
* To move around the directory structure in C, use the following:
    * `getcwd() :: Gets the current working directory`
    * `chdir() :: Sets the current working directory`

## Exec...() and the PATH variable
* `int execl(char *path, char *arg1, ..., char *argn);`
* `int execlp(char *path, char *arg1, ..., char *argn);`

* `int execv(char *path, char *argv[]);`
* `int execvp(char *path, char *argv[]);`

* The versions ending with *p* will search your PATH environment variable for the executable given in *path*
* In general, you'll want to use the versions with *p* - execlp() or execvp() - as they are much more convenient

## Execute a New Process
* exec...() *replaces* the program it is called from - it does not create a new process!
* Using fork() and exec...() , we can keep our original program going, and spawn a brand-new process!

![4](./images/1_4.png)

## Passing parameters to execlp()
* `int execlp(char *path, char *arg1, ..., char argn);`
* First parameters to execlp() is the pathname of the new program
* Remaining parameters are "command line arguments"
* First argument should be the same as the first parameter (the command itself)
* Last arguemtn must always be NULL, which indicates that there are no more parameters
* Do not pass any shell-specific operators into any member of the exec...() family, like <, >, |, &, or !, because the shell is not being invoked - only the OS is!
* Example:
    * `execlp("ls", "ls", "-a", NULL);`

* forkexec.c
```C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main() 
{
    pid_t spawnPid = -5;
    int childExitStatus = -5;

    spawnPid = fork();

    switch (spawnPid) 
    {
        case -1:
        {
            perror("Hull Breach!\n"); 
            exit(1);
            break;
        }
        case 0:
        {
            printf("CHILD(%d): Sleeping for 1 second\n", getpid());
            sleep(1);
            printf("CHILD(%d): Converting into \'ls -a\'\n", getpid());
            execlp("ls","ls","-a", NULL);
            perror("CHILD: exec failure!\n");
            exit(2);
            break;
        }
        default:
        {
            printf("PARENT(%d): Sleeping for 2 seconds\n", getpid());
            sleep(2);
            printf("PARENT(%d): Wait()ing for child(%d) to terminate\n", getpid(), spawnPid);
            pid_t actualPid = waitpid(spawnPid, &childExitStatus, 0);
            printf("PARENT(%d): Child(%d) terminated, Exiting!\n", getpid(), actualPid);
            exit(0);
            break;
        }
    }
}
```    
* **RESULTS**
```
➜  block3 git:(master) ✗ ./forkexec
PARENT(12968): sleeping for 2 seconds
CHILD(12969): Sleeping for 1 second
CHILD(12969): Converting into 'ls -a'
.       .DS_Store   02.md       04.md       forkexec.c  forktest.c  forkwaittest.c
..      01.md       03.md       forkexec    forktest    forkwaittest    images
PARENT(12968): Wait()ing for child(12969) to terminate
PARENT(12968): Child(12969) terminated, Exiting!
```

https://youtu.be/1R9h-H2UnLs?t=2670