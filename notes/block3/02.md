# Lecture 3.2 - Process Management & Zombies

[**Youtube**](https://www.youtube.com/watch?v=kx60fayG-qY)

## Running Processes
* How can we tell which processes are running? Use the `ps` command to get information about currently running processes
* `ps` by itself is really boring, and not all that useful:
```console
$ pas
  PID TTY           TIME CMD
15024 ttys000    0:00.04 bash
15026 ttys000    0:00.29 ps
```
* I've put together my two favorite ways to run it on the next few slides

## ps For Me

```console
$ # aliases go in the ~./bashrc
$ alias
...
alias psme='ps -o ppid,pid,euser,stat,%cpu,rss,args | head -n 1; ps -ell -o ppid,pid,euser,stat,%cpu,rss,args | grep brewsteb'
...
$ psme
 PPID     PID   EUSER    STAT   RSS     COMMAND
 4533   18776   root     slides 4284    sshd: brewsteb [priv]
18776   18778   brewsteb S      2112    sshd: brewsteb@pts/8
18778   18779   brewsteb Ss     2044    -bash                   
18779   18911   brewsteb R+     1840    ps -eH -o ppid,pid,euser,stat,%cpu,rss,args     
18779   18912   brewsteb S+      820    grep brewsteb
```

* PPID - Parent Process ID
* PID - Proces ID
* EUSER - Effective User ID
* STAT - Execution State
* %CPU - Percentage of CPU time this process occupies
* RSS - Real Set Size - kilobytes of RAM in use by this process
* COMMAND - THe actual command the user entered

* First State Character
    * D - Uninterruptible sleep (usually IO)
    * R - Running or runnable (on run queue)
    * S - Interruptible sleep (waiting for an event to complete)
    * T - Stopped, either by a job control signal or because it is traced
    * Z - Defunct ("zombie") process, terminated but not reaped by its parent
* Second State Character (Optional)
    * < - High-priority (not nice to other users)
    * N - Low-priority (nice to other users)
    * L - Has pages locked into memory (for real-time and custom IO)
    * s - is a session leader (closes all child processes on termination)
    * L - is multi-threaded (Uses pthread)
    * + - Is in the foreground process group

## ps For All
* ps showing all user data

```console
$ # aliases go in the ~./bashrc
$ alias
...
alias psall='ps -eH -o ppid, pid,euser,stat,%cpu,rss,args | awk '\''$1!=0'\'' | awk '\''$1!=1'\'' | awk '\''$1!=2'\'' | more'
...
$ psall
...
 PPID     PID   EUSER    STAT   RSS     COMMAND
 4533   18776   root     slides 4284    sshd: meadosc [priv]
18776   18778   meadosc S       2112    sshd: meadosc@pts/8
18778   18779   meadosc Ss  2044    -bash                   
 4533   18776   root     slides 4284    sshd: brewsteb [priv]
18776   18778   brewsteb S      2112    sshd: brewsteb@pts/8
18778   18779   brewsteb Ss     2044    -bash                   
18779   18911   brewsteb R+     1840    ps -eH -o ppid,pid,euser,stat,%cpu,rss,args     
18779   18912   brewsteb S+      820    grep brewsteb
...
```

## Zombie?
* When a child process terminates, but its parent does not wait for it, the process becomes known as a zombie (aka defunct)

## Zombies!?!
* child processes must report to their parents before their resources will be released by the OS
* If the parents aren't waiting for their children, the process become the *living undead - forever consuming, forever enslaved to a non-life of waiting and watching.*
* The purpose of a zombie process is to retain the state that `wait()` can retrieve they *want* to be harvested

## Makin' Zombies
```C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    pid_t spawnPid = -5;
    int childExitStatus = -5;

    spawnPid = fork();
    switch (spawnPid)
    {
        case -1:
            perror("Hull Breach!\n");
            exit(1);
            break;
        case 0:
            printf("CHILD: terminating!\n");    
            break;
        default:
            printf("PARENT: making child a zombie for ten seconds.\n");
            printf("PARENT: Type \"ps -elf | grep \'username\'\" to see the defunct child.\n");
            printf("Sleeping...\n");
            // Make sure all text is outputted before sleeping
            fflush(stdout);
            sleep(10)
            waitpid(spawnPid, &childExitStatus, 0);
            break;
    }
    printf("This will be executed by both of us!\n");
    exit(0);
}
```

## Output - Makin' Zombies
```console
➜  code git:(master) ✗ ./forkyouzombie
PARENT: making child a zombie for ten seconds.
PARENT: Type "ps -elf | grep 'username'" to see the defunct child.
Sleeping...
CHILD: terminating!
This will be executed by both of us!
This will be executed by both of us!
```

## How to deal with Zombies
* Zombies stay in the system until they are waited for

## Orphan Zombies
* If a parent process terminates *without* cleaning up its zombies, the zombies become orphan zombies
* Orphan are adopted by the `init` process (usually pid = 1) which periodically (in practice, very quickly) waits() for orphans
* Thus eventually, the orphan zombies die

## kill
* This UNIX is used to kill programs
    * another old version is called `kfork`
* "kill" is really a misnomer - it really just sends signals

## kill

* `kill -TERM 1234`
    * `kill <The signal to send> <The PID of the process being signaled>`      
* The given PID affects who the signal is sent to:
    * If PID > 0, then the signal will be sent to the process PID given
    * If pid == 0, then the signal is sent to all processes in the same process in the same process group as the sender (from an interactive command line, this means the foreground process group, i.e. your shell)
    * More trickiness for pid < 0
* We'll discuss more signals later, but you can use the signal `KILL` to tell a process to immediately terminate with no clean-up

## top
* `top` allows you to view the processes running on the machine in real time - one of the few animated built-in programs

## Diagnosing a Slow CPU
* The *uptime* command shows the average number of runnable processes over several different periods of time (the same info top displays)

```console
$ uptime
1:23pm up 25 day(s), 5:59, 72 users, load average: 0.18, 0.19, 0.20
```
* This shows the average number of runnable (the current running process plus the queue of processes waiting to be run) or uninterruptable (waiting for IO) processes over the last 1, 5, 15 minutes

## Diagnosing a Slow CPU - Number of Cores
```console
$ cat /proc/cpuinfo
...
cpu cores   : 8
...
```

## Diagnosing a Slow CPU - Example - Single Core
* The CPU is the champ... or it's not being given anything to do
```console
$ uptime
14:33:04 up 34 days, 5:34, 10 users, load average: 0.05, 0.15, 0.20
```
* This CPU is at max - time to upgrade!
```console
$ uptime
14:33:04 up 34 days, 5:34, 10 users, load average: 0.88, 1.03, 0.96
```
* It's 3am, and your sever is borked; start pagin everyone
```console
$ uptime
14:33:04 up 34 days, 5:34, 10 users, load average: 4.79, 7.23, 6.44
```

