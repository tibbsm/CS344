# Lecture 3.2 - Process Management & Zombies

[**Youtube**](https://www.youtube.com/watch?v=kx60fayG-qY)

## Running Processes
* How can we tell which processes are running? Use the `ps` command to get information about currently running processes
* `ps` by itself is really boring, and not all that useful:
```console
$ pas
  PID TTY           TIME CMD
15024 ttys000    0:00.04 bash
15026 ttys000    0:00.29 ps
```
* I've put together my two favorite ways to run it on the next few slides

## ps For Me

```console
$ # aliases go in the ~./bashrc
$ alias
...
alias psme='ps -o ppid,pid,euser,stat,%cpu,rss,args | head -n 1; ps -ell -o ppid,pid,euser,stat,%cpu,rss,args | grep brewsteb'
...
$ psme
 PPID 	  PID 	EUSER 	 STAT 	RSS 	COMMAND
 4533	18776	root	 slides	4284	sshd: brewsteb [priv]
18776	18778	brewsteb S 		2112    sshd: brewsteb@pts/8
18778	18779	brewsteb Ss 	2044	-bash					
18779	18911	brewsteb R+		1840	ps -eH -o ppid,pid,euser,stat,%cpu,rss,args		
18779	18912	brewsteb S+		 820	grep brewsteb
```

* PPID - Parent Process ID
* PID - Proces ID
* EUSER - Effective User ID
* STAT - Execution State
* %CPU - Percentage of CPU time this process occupies
* RSS - Real Set Size - kilobytes of RAM in use by this process
* COMMAND - THe actual command the user entered

* First State Character
	* D - Uninterruptible sleep (usually IO)
	* R - Running or runnable (on run queue)
	* S - Interruptible sleep (waiting for an event to complete)
	* T - Stopped, either by a job control signal or because it is traced
	* Z - Defunct ("zombie") process, terminated but not reaped by its parent
* Second State Character (Optional)
	* < - High-priority (not nice to other users)
	* N - Low-priority (nice to other users)
	* L - Has pages locked into memory (for real-time and custom IO)
	* s - is a session leader (closes all child processes on termination)
	* L - is multi-threaded (Uses pthread)
	* + - Is in the foreground process group

## ps For All
* ps showing all user data

```console
$ # aliases go in the ~./bashrc
$ alias
...
alias psall='ps -eH -o ppid, pid,euser,stat,%cpu,rss,args | awk '\''$1!=0'\'' | awk '\''$1!=1'\'' | awk '\''$1!=2'\'' | more'
...
$ psall
...
 PPID 	  PID 	EUSER 	 STAT 	RSS 	COMMAND
 4533	18776	root	 slides	4284	sshd: meadosc [priv]
18776	18778	meadosc S 		2112    sshd: meadosc@pts/8
18778	18779	meadosc Ss 	2044	-bash					
 4533	18776	root	 slides	4284	sshd: brewsteb [priv]
18776	18778	brewsteb S 		2112    sshd: brewsteb@pts/8
18778	18779	brewsteb Ss 	2044	-bash					
18779	18911	brewsteb R+		1840	ps -eH -o ppid,pid,euser,stat,%cpu,rss,args		
18779	18912	brewsteb S+		 820	grep brewsteb
...
```

## Zombie?
* When a child process terminates, but its parent does not wait for it, the process becomes known as a zombie (aka defunct)

## Zombies!?!
* child processes must report to their parents before their resources will be released by the OS
* If the parents aren't waiting for their children, the process become the *living undead - forever consuming, forever enslaved to a non-life of waiting and watching.*
* The purpose of a zombie process is to retain the state that `wait()` can retrieve they *want* to be harvested

## Makin' Zombies
```C
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnPid = -5;
	int childExitStatus = -5;

	spawnPid = fork();
	switch (spawnPid)
	{
		case -1:
			perror("Hull Breach!\n");
			exit(1);
			break;
		case 0:
			printf("CHILD: terminating!\n");	
			break;
		default:
			printf("PARENT: making child a zombie for ten seconds.\n");
			printf("PARENT: Type \"ps -elf | grep \'username\'\" to see the defunct child.\n");
			printf("Sleeping...\n");
			// Make sure all text is outputted before sleeping
			fflush(stdout);
			sleep(10)
			waitpid(spawnPid, &childExitStatus, 0);
			break;
	}
	printf("This will be executed by both of us!\n");
	exit(0);
}
```

https://youtu.be/kx60fayG-qY?t=687
